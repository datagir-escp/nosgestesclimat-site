{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fuse.js/dist/fuse.esm.js","webpack:///./source/components/SearchBar.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isArray","Array","toString","isString","isNumber","isDefined","Config","isCaseSensitive","includeScore","keys","shouldSort","sortFn","a","b","score","includeMatches","findAllMatches","minMatchCharLength","location","threshold","distance","useExtendedSearch","getFn","obj","path","list","arr","_get","dotIndex","indexOf","remaining","slice","len","length","push","result","baseToString","computeScore","pattern","errors","currentLocation","expectedLocation","accuracy","proximity","Math","abs","search","text","patternAlphabet","Error","patternLen","textLen","max","min","currentThreshold","bestLocation","matchMask","index","lastBitArr","finalScore","binMax","mask","MAX_BITS","binMin","binMid","floor","start","finish","bitArr","j","charMatch","charAt","isMatch","matchedIndices","matchmask","end","match","convertMaskToIndices","createPatternAlphabet","BitapSearch","this","options","toLowerCase","chunks","substring","alphabet","$","searchInString","allMatchedIndices","totalScore","hasMatches","BaseMatch","getMatch","multiRegex","singleRegex","exp","matches","ExactMatch","super","FuzzyMatch","_bitapSearch","searchers","startsWith","endsWith","searchersLen","SPACE_RE","MultiMatchSet","Set","type","SPACE","createIndex","indexedList","record","idx","keysLen","item","subRecords","stack","arrayIndex","pop","subRecord","k","arrLen","KeyStore","_keys","_keyNames","_length","weight","totalWeight","keyName","keyWeight","JSON","stringify","transformMatches","data","indices","refIndex","transformScore","registeredSearchers","Fuse","_processKeys","setCollection","listIsStringArray","setIndex","_createIndex","listIndex","_indexedList","_keyStore","opts","limit","trim","searcher","searcherClass","condition","results","_searchUsing","_computeScore","_sort","_format","searchResult","searchIn","keyNames","count","arrItem","resultsLen","numMatches","Number","EPSILON","norm","sqrt","pow","sort","finalOutput","transformers","args","register","query","split","map","filter","queryItem","found","token","isMultiMatch","isSingleMatch","parseQuery","_","qLen","pLen","constructor","has","version","config","searchWeights","fuse","onmessage","event","rules","input","replace","postMessage"],"mappings":"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","file":"d8970aa8bd3dd6a42c93.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Fuse.js v5.2.1 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2020 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nconst INFINITY = 1 / 0;\n\nconst isArray = (value) =>\n  !Array.isArray\n    ? Object.prototype.toString.call(value) === '[object Array]'\n    : Array.isArray(value);\n\n// Adapted from:\n// https://github.com/lodash/lodash/blob/f4ca396a796435422bd4fd41fadbd225edddf175/.internal/baseToString.js\nconst baseToString = (value) => {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n};\n\nconst toString = (value) => (value == null ? '' : baseToString(value));\n\nconst isString = (value) => typeof value === 'string';\n\nconst isNumber = (value) => typeof value === 'number';\n\nconst isDefined = (value) => value !== undefined && value !== null;\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const _get = (obj, path) => {\n    if (!path) {\n      // If there's no path left, we've gotten to the object we care about.\n      list.push(obj);\n    } else {\n      const dotIndex = path.indexOf('.');\n\n      let key = path;\n      let remaining = null;\n\n      if (dotIndex !== -1) {\n        key = path.slice(0, dotIndex);\n        remaining = path.slice(dotIndex + 1);\n      }\n\n      const value = obj[key];\n\n      if (isDefined(value)) {\n        if (!remaining && (isString(value) || isNumber(value))) {\n          list.push(toString(value));\n        } else if (isArray(value)) {\n          arr = true;\n          // Search each item in the array.\n          for (let i = 0, len = value.length; i < len; i += 1) {\n            _get(value[i], remaining);\n          }\n        } else if (remaining) {\n          // An object. Recurse further.\n          _get(value, remaining);\n        }\n      }\n    }\n  };\n\n  _get(obj, path);\n\n  if (arr) {\n    return list\n  }\n\n  return list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When true, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When true, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function\n  sortFn: (a, b) => a.score - b.score\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When true, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nfunction computeScore(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let matchedIndices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(`Pattern length exceeds max of ${MAX_BITS}.`)\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // A mask of the matches, used for building the indices\n  const matchMask = [];\n\n  if (includeMatches) {\n    for (let i = 0; i < textLen; i += 1) {\n      matchMask[i] = 0;\n    }\n  }\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (includeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen <= MAX_BITS - 1 ? patternLen - 1 : MAX_BITS - 2);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch && includeMatches) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i !== 0) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  let result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: !finalScore ? 0.001 : finalScore\n  };\n\n  if (includeMatches) {\n    result.matchedIndices = convertMaskToIndices(matchMask, minMatchCharLength);\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n  let len = pattern.length;\n\n  for (let i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (let i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] |= 1 << (len - i - 1);\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    let index = 0;\n    while (index < this.pattern.length) {\n      let pattern = this.pattern.substring(index, index + MAX_BITS);\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern)\n      });\n      index += MAX_BITS;\n    }\n  }\n\n  searchIn(value) {\n    let text = value.$;\n    return this.searchInString(text)\n  }\n\n  searchInString(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.matchedIndices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength\n    } = this.options;\n\n    let allMatchedIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    for (let i = 0, len = this.chunks.length; i < len; i += 1) {\n      let { pattern, alphabet } = this.chunks[i];\n\n      let result = search(text, pattern, alphabet, {\n        location: location + MAX_BITS * i,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches\n      });\n\n      const { isMatch, score, matchedIndices } = result;\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && matchedIndices) {\n        allMatchedIndices = [...allMatchedIndices, ...matchedIndices];\n      }\n    }\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.matchedIndices = allMatchedIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const matchedIndices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      matchedIndices.push([index, location - 1]);\n    }\n\n    const isMatch = !!matchedIndices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 1 : 0,\n      matchedIndices\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      matchedIndices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      matchedIndices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      matchedIndices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      matchedIndices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      matchedIndices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchInString(text)\n  }\n}\n\n// ❗Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, ExactMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that match `jscript`             |\n * | `'python`   | exact-match                | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(value) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    let text = value.$;\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let indices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      indices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, matchedIndices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              indices = [...indices, ...matchedIndices];\n            } else {\n              indices.push(matchedIndices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          indices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.matchedIndices = indices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst SPACE = /[^ ]+/g;\n\nfunction createIndex(keys, list, { getFn = Config.getFn } = {}) {\n  let indexedList = [];\n\n  // List is Array<String>\n  if (isString(list[0])) {\n    // Iterate over every string in the list\n    for (let i = 0, len = list.length; i < len; i += 1) {\n      const value = list[i];\n\n      if (isDefined(value)) {\n        let record = {\n          $: value,\n          idx: i,\n          t: value.match(SPACE).length\n        };\n\n        indexedList.push(record);\n      }\n    }\n  } else {\n    // List is Array<Object>\n    const keysLen = keys.length;\n\n    for (let i = 0, len = list.length; i < len; i += 1) {\n      let item = list[i];\n\n      let record = { idx: i, $: {} };\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      for (let j = 0; j < keysLen; j += 1) {\n        let key = keys[j];\n        let value = getFn(item, key);\n\n        if (!isDefined(value)) {\n          continue\n        }\n\n        if (isArray(value)) {\n          let subRecords = [];\n          const stack = [{ arrayIndex: -1, value }];\n\n          while (stack.length) {\n            const { arrayIndex, value } = stack.pop();\n\n            if (!isDefined(value)) {\n              continue\n            }\n\n            if (isString(value)) {\n              let subRecord = {\n                $: value,\n                idx: arrayIndex,\n                t: value.match(SPACE).length\n              };\n              subRecords.push(subRecord);\n            } else if (isArray(value)) {\n              for (let k = 0, arrLen = value.length; k < arrLen; k += 1) {\n                stack.push({\n                  arrayIndex: k,\n                  value: value[k]\n                });\n              }\n            }\n          }\n          record.$[key] = subRecords;\n        } else {\n          let subRecord = {\n            $: value,\n            t: value.match(SPACE).length\n          };\n\n          record.$[key] = subRecord;\n        }\n      }\n\n      indexedList.push(record);\n    }\n  }\n\n  return indexedList\n}\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = {};\n    this._keyNames = [];\n    this._length = keys.length;\n\n    // Iterate over every key\n    if (keys.length && isString(keys[0])) {\n      for (let i = 0; i < this._length; i += 1) {\n        const key = keys[i];\n        this._keys[key] = {\n          weight: 1\n        };\n        this._keyNames.push(key);\n      }\n    } else {\n      let totalWeight = 0;\n\n      for (let i = 0; i < this._length; i += 1) {\n        const key = keys[i];\n\n        if (!Object.prototype.hasOwnProperty.call(key, 'name')) {\n          throw new Error('Missing \"name\" property in key object')\n        }\n\n        const keyName = key.name;\n        this._keyNames.push(keyName);\n\n        if (!Object.prototype.hasOwnProperty.call(key, 'weight')) {\n          throw new Error('Missing \"weight\" property in key object')\n        }\n\n        const weight = key.weight;\n\n        if (weight <= 0 || weight >= 1) {\n          throw new Error(\n            '\"weight\" property in key must be in the range of (0, 1)'\n          )\n        }\n\n        this._keys[keyName] = {\n          weight\n        };\n\n        totalWeight += weight;\n      }\n\n      // Normalize weights so that their sum is equal to 1\n      for (let i = 0; i < this._length; i += 1) {\n        const keyName = this._keyNames[i];\n        const keyWeight = this._keys[keyName].weight;\n        this._keys[keyName].weight = keyWeight / totalWeight;\n      }\n    }\n  }\n  get(key, name) {\n    return this._keys[key] ? this._keys[key][name] : -1\n  }\n  keys() {\n    return this._keyNames\n  }\n  count() {\n    return this._length\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  for (let i = 0, len = matches.length; i < len; i += 1) {\n    let match = matches[i];\n\n    if (!isDefined(match.indices) || match.indices.length === 0) {\n      continue\n    }\n\n    let obj = {\n      indices: match.indices,\n      value: match.value\n    };\n\n    if (match.key) {\n      obj.key = match.key;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  }\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nclass Fuse {\n  constructor(list, options = {}, index = null) {\n    this.options = { ...Config, ...options };\n\n    this._processKeys(this.options.keys);\n    this.setCollection(list, index);\n  }\n\n  setCollection(list, index = null) {\n    this.list = list;\n    this.listIsStringArray = isString(list[0]);\n\n    if (index) {\n      this.setIndex(index);\n    } else {\n      this.setIndex(this._createIndex());\n    }\n  }\n\n  setIndex(listIndex) {\n    this._indexedList = listIndex;\n  }\n\n  _processKeys(keys) {\n    this._keyStore = new KeyStore(keys);\n  }\n\n  _createIndex() {\n    return createIndex(this._keyStore.keys(), this.list, {\n      getFn: this.options.getFn\n    })\n  }\n\n  search(pattern, opts = { limit: false }) {\n    pattern = pattern.trim();\n\n    if (!pattern.length) {\n      return []\n    }\n\n    const { shouldSort } = this.options;\n\n    let searcher = null;\n\n    for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n      let searcherClass = registeredSearchers[i];\n      if (searcherClass.condition(pattern, this.options)) {\n        searcher = new searcherClass(pattern, this.options);\n        break\n      }\n    }\n\n    if (!searcher) {\n      searcher = new BitapSearch(pattern, this.options);\n    }\n\n    let results = this._searchUsing(searcher);\n\n    this._computeScore(results);\n\n    if (shouldSort) {\n      this._sort(results);\n    }\n\n    if (opts.limit && isNumber(opts.limit)) {\n      results = results.slice(0, opts.limit);\n    }\n\n    return this._format(results)\n  }\n\n  _searchUsing(searcher) {\n    const list = this._indexedList;\n    const results = [];\n    const { includeMatches } = this.options;\n\n    // List is Array<String>\n    if (this.listIsStringArray) {\n      // Iterate over every string in the list\n      for (let i = 0, len = list.length; i < len; i += 1) {\n        let value = list[i];\n        let { $: text, idx, t } = value;\n\n        if (!isDefined(text)) {\n          continue\n        }\n\n        let searchResult = searcher.searchIn(value);\n\n        const { isMatch, score } = searchResult;\n\n        if (!isMatch) {\n          continue\n        }\n\n        let match = { score, value: text, t };\n\n        if (includeMatches) {\n          match.indices = searchResult.matchedIndices;\n        }\n\n        results.push({\n          item: text,\n          idx,\n          matches: [match]\n        });\n      }\n    } else {\n      // List is Array<Object>\n      const keyNames = this._keyStore.keys();\n      const keysLen = this._keyStore.count();\n\n      for (let i = 0, len = list.length; i < len; i += 1) {\n        let { $: item, idx } = list[i];\n\n        if (!isDefined(item)) {\n          continue\n        }\n\n        let matches = [];\n\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        for (let j = 0; j < keysLen; j += 1) {\n          let key = keyNames[j];\n          let value = item[key];\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isArray(value)) {\n            for (let k = 0, len = value.length; k < len; k += 1) {\n              let arrItem = value[k];\n              const { $: text, idx, t } = arrItem;\n\n              if (!isDefined(text)) {\n                continue\n              }\n\n              let searchResult = searcher.searchIn(arrItem);\n\n              const { isMatch, score } = searchResult;\n\n              if (!isMatch) {\n                continue\n              }\n\n              let match = { score, key, value: text, idx, t };\n\n              if (includeMatches) {\n                match.indices = searchResult.matchedIndices;\n              }\n\n              matches.push(match);\n            }\n          } else {\n            const { $: text, t } = value;\n\n            let searchResult = searcher.searchIn(value);\n\n            const { isMatch, score } = searchResult;\n\n            if (!isMatch) {\n              continue\n            }\n\n            let match = { score, key, value: text, t };\n\n            if (includeMatches) {\n              match.indices = searchResult.matchedIndices;\n            }\n\n            matches.push(match);\n          }\n        }\n\n        if (matches.length) {\n          results.push({\n            idx,\n            item,\n            matches\n          });\n        }\n      }\n    }\n\n    return results\n  }\n\n  // Practical scoring function\n  _computeScore(results) {\n    const resultsLen = results.length;\n\n    for (let i = 0; i < resultsLen; i += 1) {\n      const result = results[i];\n      const matches = result.matches;\n      const numMatches = matches.length;\n\n      let totalScore = 1;\n\n      for (let j = 0; j < numMatches; j += 1) {\n        const match = matches[j];\n        const { key, t } = match;\n\n        const keyWeight = this._keyStore.get(key, 'weight');\n        const weight = keyWeight > -1 ? keyWeight : 1;\n        const score =\n          match.score === 0 && keyWeight > -1 ? Number.EPSILON : match.score;\n\n        // Field-length norm: the shorter the field, the higher the weight.\n        const norm = 1 / Math.sqrt(t);\n\n        totalScore *= Math.pow(score, weight * norm);\n      }\n\n      result.score = totalScore;\n    }\n  }\n\n  _sort(results) {\n    results.sort(this.options.sortFn);\n  }\n\n  _format(results) {\n    const finalOutput = [];\n\n    const { includeMatches, includeScore } = this.options;\n\n    let transformers = [];\n\n    if (includeMatches) transformers.push(transformMatches);\n    if (includeScore) transformers.push(transformScore);\n\n    for (let i = 0, len = results.length; i < len; i += 1) {\n      const result = results[i];\n      const { idx } = result;\n\n      const data = {\n        item: this.list[idx],\n        refIndex: idx\n      };\n\n      if (transformers.length) {\n        for (let j = 0, len = transformers.length; j < len; j += 1) {\n          transformers[j](result, data);\n        }\n      }\n\n      finalOutput.push(data);\n    }\n\n    return finalOutput\n  }\n}\n\nregister(ExtendedSearch);\n\nFuse.version = '5.2.1';\nFuse.createIndex = createIndex;\nFuse.config = Config;\n\nexport default Fuse;\n","import Fuse from 'fuse.js'\r\n\r\nlet searchWeights = [\r\n\t{\r\n\t\tname: 'espace',\r\n\t\tweight: 0.6\r\n\t},\r\n\t{\r\n\t\tname: 'title',\r\n\t\tweight: 0.4\r\n\t}\r\n]\r\n\r\nlet fuse = null\r\nonmessage = function(event) {\r\n\tif (event.data.rules)\r\n\t\tfuse = new Fuse(event.data.rules, {\r\n\t\t\tkeys: searchWeights,\r\n\t\t\tincludeMatches: true,\r\n\t\t\tminMatchCharLength: 2,\r\n\t\t\tuseExtendedSearch: true,\r\n\t\t\tdistance: 50,\r\n\t\t\tthreshold: 0.3\r\n\t\t})\r\n\r\n\tif (event.data.input) {\r\n\t\tlet results = [\r\n\t\t\t...fuse.search(\r\n\t\t\t\tevent.data.input + '|' + event.data.input.replace(/ /g, '|')\r\n\t\t\t)\r\n\t\t]\r\n\t\tpostMessage(results)\r\n\t}\r\n}\r\n"],"sourceRoot":""}